const fs = require("fs");
const Reverso = require("reverso-api");
const chromium = require("@sparticuz/chromium");
const axios = require("axios");

let reversoInstancePromise = null;
async function getReverso() {
  // No Vercel, sempre usa Gemini como fallback
  if (process.env.VERCEL || process.env.NODE_ENV === 'production') {
    console.log("üåê Ambiente Vercel detectado - usando apenas Gemini");
    return null; // For√ßa uso do Gemini
  }
  
  if (!reversoInstancePromise) {
    reversoInstancePromise = (async () => {
      try {
        const executablePath = await chromium.executablePath();
        return new Reverso({
          puppeteerOptions: {
            headless: true,
            executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || executablePath,
            args: chromium.args,
            defaultViewport: chromium.defaultViewport,
            ignoreHTTPSErrors: true,
            timeout: 60000,
          },
        });
      } catch (error) {
        console.warn("‚ö†Ô∏è Erro ao inicializar Reverso, usando Gemini:", error.message);
        return null;
      }
    })();
  }
  return reversoInstancePromise;
}
const dictionary = require("./dictionary.controller.js");
const gAudio = require("./audioController.js");

// Cache system
const cache = new Map();
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

// Cache para frases j√° mostradas (evita duplicatas)
const shownPhrasesCache = new Map();

// Check if word is in cache and not expired
const getFromCache = (word) => {
  const cached = cache.get(word);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  return null;
};

// Save to cache
const saveToCache = (word, data) => {
  cache.set(word, {
    data,
    timestamp: Date.now()
  });
};

// Check if there are phrases available for a given word
const hasPhrases = async (word) => {
  try {
    const reverso = await getReverso();
    const response = await reverso.getTranslation(
      word,
      "english",
      "portuguese"
    );
    const translations = [...new Set(response.translations)];
    return translations.length > 0; // Returns true if there are translations, otherwise false
  } catch (error) {
    console.error(`Failed to translate word: ${word}. Error: ${error.message}`);
    return false; // Return false if there was an error
  }
};

// Removido: gerador de exemplos gen√©ricos (substitu√≠do por Reverso + Gemini)

// Generate contextual phrases using Gemini AI
const generateGeminiPhrases = async (word, excludePhrases = []) => {
  try {
    console.log(`ü§ñ Gerando frases contextuais com Gemini para: ${word}`);
    
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
    
    if (!GEMINI_API_KEY) {
      console.error('‚ùå GEMINI_API_KEY n√£o configurada nas vari√°veis de ambiente');
      return [];
    }
    
    // Cria lista de frases j√° mostradas para evitar duplicatas
    const excludeText = excludePhrases.length > 0 ? 
      `\n\nIMPORTANT: Do NOT generate any of these phrases (they are already shown):\n${excludePhrases.map(p => `- "${p.english}"`).join('\n')}` : '';
    
    const prompt = `Generate 8 natural, contextual example sentences in English using the word "${word}" and provide their Portuguese translations. 

Format the response as a JSON array with this exact structure:
[
  {
    "english": "Example sentence in English with the word naturally used",
    "portuguese": "Tradu√ß√£o em portugu√™s"
  }
]

Make sure the sentences are:
- Natural and contextual (not generic templates)
- Use the word "${word}" in different contexts
- Show different meanings/uses of the word
- Are appropriate for language learning
- COMPLETELY DIFFERENT from any previously shown phrases${excludeText}

Example for "cat":
[
  {
    "english": "The cat is sleeping peacefully on the windowsill.",
    "portuguese": "O gato est√° dormindo tranquilamente no parapeito da janela."
  }
]

Generate exactly 8 examples for "${word}":`;

    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        contents: [{ parts: [{ text: prompt }] }]
      },
      { 
        headers: { 'Content-Type': 'application/json' },
        timeout: 30000
      }
    );

    const text = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!text) {
      console.warn("Resposta vazia do Gemini");
      return [];
    }

    // Tenta extrair JSON da resposta
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      const phrases = JSON.parse(jsonMatch[0]);
      console.log(`‚úÖ Gemini gerou ${phrases.length} frases para: ${word}`);
      
      // Normaliza as propriedades das frases
      const normalizedPhrases = phrases.map(phrase => ({
        english: phrase.english || phrase.ingl√™s || '',
        portuguese: phrase.portuguese || phrase.portugu√™s || phrase.tradu√ß√£o || ''
      })).filter(phrase => phrase.english && phrase.portuguese);
      
      console.log(`üìù Frases normalizadas: ${normalizedPhrases.length}`);
      return normalizedPhrases;
    } else {
      console.warn("N√£o foi poss√≠vel extrair JSON da resposta do Gemini");
      return [];
    }

  } catch (error) {
    console.error(`‚ùå Erro ao gerar frases com Gemini para ${word}:`, error.message);
    return [];
  }
};

// Generate translations using Gemini AI
const generateGeminiTranslations = async (word) => {
  try {
    console.log(`ü§ñ Gerando tradu√ß√µes com Gemini para: ${word}`);
    
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
    
    if (!GEMINI_API_KEY) {
      console.error('‚ùå GEMINI_API_KEY n√£o configurada nas vari√°veis de ambiente');
      return [];
    }
    
    const prompt = `Provide 10 different Portuguese translations for the English word "${word}". 

IMPORTANT RULES:
- NEVER include the original English word "${word}" in the translations
- Only provide Portuguese words/phrases
- Include common translations, synonyms, and variations
- Consider different contexts and meanings
- Include formal and informal versions when applicable

Format as a simple JSON array of strings:
["translation1", "translation2", "translation3", ...]

Example for "book":
["livro", "reservar", "agendar", "marcar", "caderno", "obra", "manual", "carteira", "cat√°logo", "regras"]

Generate exactly 10 DIFFERENT Portuguese translations for "${word}":`;

    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        contents: [{ parts: [{ text: prompt }] }]
      },
      { 
        headers: { 'Content-Type': 'application/json' },
        timeout: 30000
      }
    );

    const text = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!text) {
      console.warn("Resposta vazia do Gemini para tradu√ß√µes");
      return [];
    }

    // Tenta extrair JSON da resposta
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      const translations = JSON.parse(jsonMatch[0]);
      console.log(`‚úÖ Gemini gerou ${translations.length} tradu√ß√µes para: ${word}`);
      
      // Filtra tradu√ß√µes v√°lidas e remove a palavra original
      const validTranslations = translations
        .filter(t => t && t.trim())
        .filter(t => t.toLowerCase() !== word.toLowerCase()) // Remove a palavra original
        .filter(t => !t.includes(word.toLowerCase())) // Remove tradu√ß√µes que cont√™m a palavra original
        .filter(t => t.length > 1); // Remove tradu√ß√µes muito curtas
      
      console.log(`üìù Tradu√ß√µes filtradas: ${validTranslations.length} (removidas: ${translations.length - validTranslations.length})`);
      return validTranslations;
    } else {
      console.warn("N√£o foi poss√≠vel extrair JSON das tradu√ß√µes do Gemini");
      return [];
    }

  } catch (error) {
    console.error(`‚ùå Erro ao gerar tradu√ß√µes com Gemini para ${word}:`, error.message);
    return [];
  }
};

// Generate up to 5 phrases: try Reverso first, then complete with Gemini
const generatePhrases = async (word) => {
  // No Vercel, sempre usa Gemini
  if (process.env.VERCEL || process.env.NODE_ENV === 'production') {
    console.log("üåê Usando Gemini para frases (ambiente Vercel)");
    const geminiPhrases = await generateGeminiPhrases(word);
    return geminiPhrases.slice(0, 5);
  }

  let retryCount = 0;
  const maxRetries = 3;

  while (retryCount < maxRetries) {
    try {
      console.log(`Tentativa ${retryCount + 1} de buscar frases para:`, word);
      const reverso = await getReverso();
      
      if (!reverso) {
        console.log("ü§ñ Reverso n√£o dispon√≠vel, usando Gemini");
        const geminiPhrases = await generateGeminiPhrases(word);
        return geminiPhrases.slice(0, 5);
      }
      
      const response = await reverso.getContext(word, "english", "portuguese");
      
      if (!response) {
        console.warn("Resposta vazia do Reverso API");
        retryCount++;
        continue;
      }

      if (!response.ok) {
        console.warn("Resposta inv√°lida do Reverso API:", response);
        retryCount++;
        continue;
      }

      if (!response.examples || !Array.isArray(response.examples)) {
        console.warn("Nenhum exemplo encontrado para a palavra:", word);
        break;
      }

      console.log("Exemplos encontrados:", response.examples.length);
      
      const reversoPhrases = response.examples.map((example) => {
        console.log("Processando exemplo:", example);
        // Tenta diferentes estruturas de dados poss√≠veis
        const english = example.source || example.text || example.english || example.original || "";
        const portuguese = example.target || example.translation || example.portuguese || example.translated || "";
        
        return {
          english: english,
          portuguese: portuguese
        };
      }).filter(phrase => {
        const isValid = phrase.english && phrase.portuguese && phrase.english.trim() && phrase.portuguese.trim();
        if (!isValid) {
          console.log("Frase filtrada (inv√°lida):", phrase);
        }
        return isValid;
      });

      console.log("Frases processadas (Reverso):", reversoPhrases.length);

      // Completa com Gemini at√© 5 frases
      let finalPhrases = [...reversoPhrases].slice(0, 5);
      console.log(`üìä Frases do Reverso: ${finalPhrases.length}`);
      
      if (finalPhrases.length < 5) {
        const needed = 5 - finalPhrases.length;
        console.log(`ü§ñ Buscando ${needed} frases adicionais no Gemini para:`, word);
        const geminiPhrases = await generateGeminiPhrases(word);
        console.log(`üìù Gemini retornou ${geminiPhrases.length} frases`);
        
        for (const p of geminiPhrases) {
          if (finalPhrases.length >= 5) break;
          if (p.english && p.portuguese) {
            finalPhrases.push(p);
            console.log(`‚úÖ Adicionada frase do Gemini: ${p.english.substring(0, 50)}...`);
          }
        }
      }

      console.log(`üìä Total de frases finais: ${finalPhrases.length}`);
      return finalPhrases;
    } catch (err) {
      console.error(`Erro na tentativa ${retryCount + 1}:`, err.message);
      retryCount++;
      
      if (retryCount === maxRetries) {
        console.error("N√∫mero m√°ximo de tentativas atingido para:", word);
        console.log("ü§ñ Usando Gemini como fallback para:", word);
        const geminiPhrases = await generateGeminiPhrases(word);
        return geminiPhrases.slice(0, 5);
      }
      
      // Espera 2 segundos antes de tentar novamente
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  
  // Fallback final: Gemini
  console.log("ü§ñ Usando Gemini como fallback final para:", word);
  const geminiPhrases = await generateGeminiPhrases(word);
  return geminiPhrases.slice(0, 5);
};

// Generate translations: try Reverso first, then complete with Gemini (at√© 15 tradu√ß√µes)
const generateTranslate = async (word) => {
  // No Vercel, sempre usa Gemini
  if (process.env.VERCEL || process.env.NODE_ENV === 'production') {
    console.log("üåê Usando Gemini para tradu√ß√µes (ambiente Vercel)");
    const geminiTranslations = await generateGeminiTranslations(word);
    return geminiTranslations.slice(0, 15);
  }

  try {
    const reverso = await getReverso();
    
    if (!reverso) {
      console.log("ü§ñ Reverso n√£o dispon√≠vel, usando Gemini");
      const geminiTranslations = await generateGeminiTranslations(word);
      return geminiTranslations.slice(0, 15);
    }
    
    const response = await reverso.getTranslation(
      word,
      "english",
      "portuguese"
    );
    
    // Verifica se a resposta e translations existem
    if (!response || !response.translations || !Array.isArray(response.translations)) {
      console.warn("Resposta de tradu√ß√£o inv√°lida para:", word);
      console.log("ü§ñ Usando Gemini para tradu√ß√µes de:", word);
      const geminiTranslations = await generateGeminiTranslations(word);
      return geminiTranslations.slice(0, 15); // At√© 15 tradu√ß√µes
    }
    
    // Filtra tradu√ß√µes do Reverso, removendo a palavra original
    const reversoTranslations = [...new Set(response.translations)]
      .filter(t => t && t.trim())
      .filter(t => t.toLowerCase() !== word.toLowerCase()) // Remove a palavra original
      .filter(t => !t.includes(word.toLowerCase())) // Remove tradu√ß√µes que cont√™m a palavra original
      .filter(t => t.length > 1); // Remove tradu√ß√µes muito curtas
    
    if (reversoTranslations.length === 0) {
      console.log("ü§ñ Nenhuma tradu√ß√£o v√°lida do Reverso, usando Gemini para:", word);
      const geminiTranslations = await generateGeminiTranslations(word);
      return geminiTranslations.slice(0, 15); // At√© 15 tradu√ß√µes
    }
    
    // Sempre completa com Gemini para ter mais tradu√ß√µes
    console.log(`üìù Reverso retornou ${reversoTranslations.length} tradu√ß√µes v√°lidas, completando com Gemini para:`, word);
    const geminiTranslations = await generateGeminiTranslations(word);
    
    // Combina tradu√ß√µes, removendo duplicatas e a palavra original
    const allTranslations = [...reversoTranslations];
    for (const geminiTrans of geminiTranslations) {
      if (!allTranslations.some(t => t.toLowerCase() === geminiTrans.toLowerCase()) &&
          geminiTrans.toLowerCase() !== word.toLowerCase() &&
          !geminiTrans.includes(word.toLowerCase())) {
        allTranslations.push(geminiTrans);
      }
      if (allTranslations.length >= 15) break; // At√© 15 tradu√ß√µes
    }
    
    console.log(`üìä Total de tradu√ß√µes geradas: ${allTranslations.length}`);
    return allTranslations;
    
  } catch (error) {
    console.error(`Erro ao traduzir palavra: ${word}. Erro: ${error.message}`);
    console.log("ü§ñ Usando Gemini como fallback para tradu√ß√µes de:", word);
    const geminiTranslations = await generateGeminiTranslations(word);
    return geminiTranslations.slice(0, 15); // At√© 15 tradu√ß√µes
  }
};

// Get all information about a word including translation, phrases, IPA pronunciation, etc.
const getInfoWord = async (word) => {
  try {
    let text = word.toLowerCase().trim();

    // Check cache first
    const cachedData = getFromCache(text);
    if (cachedData) {
      return cachedData;
    }

    // Executa todas as opera√ß√µes em paralelo
    const [translation, phrasesResult, ipaDetails, audioResult] = await Promise.all([
      generateTranslate(text),
      generatePhrases(text),
      dictionary.getDetailsOfTranscription(text),
      gAudio.generateAudio(text).catch(err => {
        console.warn(`Erro ao gerar √°udio para ${text}:`, err.message);
        return null;
      })
    ]);

    const [ipa, pronounce] = ipaDetails || ["IPA indispon√≠vel", "Pron√∫ncia indispon√≠vel"];

    // Create an object containing all information about the word
    const wordInfo = {
      word: text,
      audio: (audioResult && !process.env.VERCEL && process.env.NODE_ENV !== 'production') ? "../audio.mp3" : null,
      translation: translation || ["Tradu√ß√£o indispon√≠vel"],
      phrases: Array.isArray(phrasesResult) ? phrasesResult : [],
      ipa: ipa,
      pronounce: pronounce,
    };

    console.log("Informa√ß√µes da palavra geradas:", {
      word: text,
      translationCount: wordInfo.translation.length,
      phrasesCount: wordInfo.phrases.length,
      hasAudio: !!wordInfo.audio
    });

    // Save to cache
    saveToCache(text, wordInfo);

    return wordInfo;
  } catch (error) {
    console.error("Erro ao obter informa√ß√µes da palavra:", error);
    // Retorna um objeto com valores padr√£o em caso de erro
    return {
      word: word.toLowerCase().trim(),
      audio: null,
      translation: ["Tradu√ß√£o indispon√≠vel"],
      phrases: [],
      ipa: "IPA indispon√≠vel",
      pronounce: "Pron√∫ncia indispon√≠vel",
    };
  }
};

// Generate more unique phrases for a word
const generateMorePhrases = async (word, existingPhrases = []) => {
  try {
    console.log(`üîÑ Gerando mais frases √∫nicas para: ${word}`);
    
    // Verifica se j√° temos muitas frases (limite de 20)
    if (existingPhrases.length >= 20) {
      console.log("üìä Limite de frases atingido para:", word);
      return {
        phrases: [],
        hasMore: false,
        message: "Limite de frases atingido (20 frases). Todas as varia√ß√µes dispon√≠veis foram mostradas."
      };
    }
    
    // Gera novas frases excluindo as j√° existentes
    const newPhrases = await generateGeminiPhrases(word, existingPhrases);
    
    if (newPhrases.length === 0) {
      return {
        phrases: [],
        hasMore: false,
        message: "N√£o foi poss√≠vel gerar mais frases √∫nicas para esta palavra."
      };
    }
    
    // Filtra duplicatas adicionais
    const uniquePhrases = newPhrases.filter(newPhrase => 
      !existingPhrases.some(existing => 
        existing.english.toLowerCase() === newPhrase.english.toLowerCase()
      )
    );
    
    console.log(`‚úÖ Encontradas ${uniquePhrases.length} frases √∫nicas novas para: ${word}`);
    console.log('üìù Frases √∫nicas geradas:', uniquePhrases);
    
    const finalPhrases = uniquePhrases.slice(0, 5);
    console.log('üì§ Retornando frases:', finalPhrases);
    
    return {
      phrases: finalPhrases, // M√°ximo 5 por vez
      hasMore: uniquePhrases.length >= 5,
      message: uniquePhrases.length < 5 ? "Poucas varia√ß√µes restantes dispon√≠veis." : null
    };
    
  } catch (error) {
    console.error(`‚ùå Erro ao gerar mais frases para ${word}:`, error.message);
    return {
      phrases: [],
      hasMore: false,
      message: "Erro ao gerar mais frases. Tente novamente."
    };
  }
};


module.exports = {
  generatePhrases,
  generateTranslate,
  getInfoWord,
  hasPhrases,
  generateGeminiTranslations,
  generateMorePhrases,
};
